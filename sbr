package br.com.litesshbrasil;

import static com.google.android.play.core.install.model.ActivityResult.RESULT_IN_APP_UPDATE_FAILED;
import static com.google.android.play.core.install.model.AppUpdateType.IMMEDIATE;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.TrafficStats;
import android.net.Uri;
import android.net.VpnService;
import android.os.Build;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.os.Handler;
import android.os.PersistableBundle;
import android.os.Vibrator;
import android.preference.PreferenceManager;
import android.telephony.TelephonyManager;
import android.text.Html;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.method.LinkMovementMethod;
import android.text.style.ForegroundColorSpan;
import android.util.DisplayMetrics;
import android.view.Gravity;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.FrameLayout;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.Spinner;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.app.AppCompatDelegate;
import androidx.coordinatorlayout.widget.CoordinatorLayout;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.lifecycle.Observer;
import androidx.lifecycle.ViewModelProviders;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.viewpager.widget.PagerAdapter;
import androidx.viewpager.widget.ViewPager;
import com.github.rubensousa.bottomsheetbuilder.BottomSheetBuilder;
import com.github.rubensousa.bottomsheetbuilder.adapter.BottomSheetItemClickListener;
import com.google.android.gms.ads.AdError;
import com.google.android.gms.ads.AdListener;
import com.google.android.gms.ads.AdRequest;
import com.google.android.gms.ads.AdSize;
import com.google.android.gms.ads.AdView;
import com.google.android.gms.ads.FullScreenContentCallback;
import com.google.android.gms.ads.LoadAdError;
import com.google.android.gms.ads.MobileAds;
import com.google.android.gms.ads.initialization.InitializationStatus;
import com.google.android.gms.ads.initialization.OnInitializationCompleteListener;
import com.google.android.gms.ads.interstitial.InterstitialAd;
import com.google.android.gms.ads.interstitial.InterstitialAdLoadCallback;
import com.google.android.gms.ads.rewarded.RewardedAd;
import com.google.android.gms.ads.rewarded.RewardedAdLoadCallback;
import com.google.android.gms.tasks.Task;
import com.google.android.material.bottomnavigation.BottomNavigationView;
import com.google.android.material.bottomsheet.BottomSheetBehavior;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.snackbar.Snackbar;
import com.google.android.play.core.appupdate.AppUpdateInfo;
import com.google.android.play.core.appupdate.AppUpdateManager;
import com.google.android.play.core.appupdate.AppUpdateManagerFactory;
import com.google.android.play.core.install.InstallStateUpdatedListener;
import com.google.android.play.core.install.model.InstallStatus;
import com.google.android.play.core.install.model.UpdateAvailability;
import com.google.android.play.core.review.ReviewInfo;
import com.google.android.play.core.review.ReviewManager;
import com.google.android.play.core.review.ReviewManagerFactory;
import com.google.android.ump.ConsentForm;
import com.google.android.ump.ConsentInformation;
import com.google.android.ump.ConsentRequestParameters;
import com.google.android.ump.FormError;
import com.google.android.ump.UserMessagingPlatform;
import com.luseen.spacenavigation.SpaceItem;
import com.luseen.spacenavigation.SpaceNavigationView;
import com.luseen.spacenavigation.SpaceOnClickListener;
import com.suke.widget.SwitchButton;
import com.technore.v2ray.service.V2RayServiceManager;
import com.technore.v2ray.util.V2ConfigManager;
import com.technore.v2ray.viewmodel.MainViewModel;
import com.tunnel.xsocks.adapter.MainRecyclerAdapter;
import com.valdesekamdem.library.mdtoast.MDToast;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.Reader;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import br.com.litesshbrasil.activities.AboutActivity;
import br.com.litesshbrasil.activities.ConfigGeralActivity;
import br.com.litesshbrasil.config.Settings;
import br.com.litesshbrasil.fragments.ExitDialogFragment;
import br.com.litesshbrasil.logger.ConnectionStatus;
import br.com.litesshbrasil.logger.SkStatus;
import br.com.litesshbrasil.model.ExceptionHandler;
import br.com.litesshbrasil.service.SSHService;
import br.com.litesshbrasil.service.adapter.LogsAdapter;
import br.com.litesshbrasil.service.adapter.SpinnerAdapter;
import br.com.litesshbrasil.tunnel.TunnelManagerHelper;
import br.com.litesshbrasil.tunnel.TunnelUtils;
import br.com.litesshbrasil.util.ConfigUpdate;
import br.com.litesshbrasil.util.GETRequest;
import br.com.litesshbrasil.util.ServerStatusAdapter;
import br.com.litesshbrasil.util.Utils;
import br.com.litesshbrasil.util.securepreferences.crypto.AESCrypt;
import br.com.litesshbrasil.view.CustomDialog;
import br.com.litesshbrasil.view.TabBarView;
import br.com.litesshbrasil.wifi.ui.ProxySettings;
import cn.pedant.SweetAlert.widget.SweetAlertDialog;

public class MainActivity extends AppCompatActivity implements
		View.OnClickListener, BottomNavigationView.OnNavigationItemSelectedListener,
		DialogInterface.OnClickListener,SkStatus.StateListener  {
	final int PERMISSION_REQUEST_CODE =112;
	private static final String UPDATE_VIEWS = "MainUpdate";
	public static final String OPEN_LOGS = "br.com.litesshbrasil:openLogs";
	private AppUpdateManager mAppUpdateManager;
	private final int RC_APP_UPDATE = 999;
	private int inAppUpdateType;
	private com.google.android.gms.tasks.Task<com.google.android.play.core.appupdate.AppUpdateInfo> appUpdateInfoTask;
	private InstallStateUpdatedListener installStateUpdatedListener;
	private Handler mHandler;
	public static ViewPager mPager;
	private TextView statusconenect;
	private ConsentInformation consentInformation;
	private final Runnable mRunnable = new Runnable() {
		@SuppressLint("SetTextI18n")
		public void run() {
            TextView textView = MainActivity.this.findViewById(R.id.RX);
			TextView textView2 = MainActivity.this.findViewById(R.id.TX);
			long totalRxBytes = TrafficStats.getTotalRxBytes();
			long totalRxBytes2 = TrafficStats.getTotalRxBytes() - MainActivity.this.mStartRX;
			String str = " KB";
			textView.setText(totalRxBytes2 + str);
			String gb = " GB";
			String mb = " MB";
			String kb = " KB";
			if (totalRxBytes2 >= 1024) {
				totalRxBytes2 /= 1024;
				textView.setText(totalRxBytes2 + kb);
				if (totalRxBytes2 >= 1024) {
					totalRxBytes2 /= 1024;
					textView.setText(totalRxBytes2 + mb);
					if (totalRxBytes2 >= 1024) {
						textView.setText(totalRxBytes2 / 1024 + gb);
					}
				}
			}
			MainActivity.this.mStartRX = totalRxBytes;
			totalRxBytes = TrafficStats.getTotalTxBytes();
			totalRxBytes2 = TrafficStats.getTotalTxBytes() - MainActivity.this.mStartTX;
			textView2.setText(totalRxBytes2 + str);
			if (totalRxBytes2 >= 1024) {
				totalRxBytes2 /= 1024;
				textView2.setText(totalRxBytes2 + kb);
				if (totalRxBytes2 >= 1024) {
					totalRxBytes2 /= 1024;
					textView2.setText(totalRxBytes2 + mb);
					if (totalRxBytes2 >= 1024) {
						textView2.setText(totalRxBytes2 / 1024 + gb);
					}
				}
			}
			MainActivity.this.mStartTX = totalRxBytes;
			MainActivity.this.mHandler2.postDelayed(MainActivity.this.mRunnable, 1000);
		}
	};
	private long mStartRX = 0;
	private long mStartTX = 0;
	private SweetAlertDialog pDialog;
	private final Handler mHandler2 = new Handler();
	private MainViewModel mainViewModel;
	private MainRecyclerAdapter adapter;
	private TextView textstatus;
	@SuppressLint("StaticFieldLeak")
	private static Spinner serverSpinner;
	@SuppressLint("StaticFieldLeak")
	public static Spinner payloadSpinner;
	private ArrayList<JSONObject> serverList;
	private ArrayList<JSONObject> payloadList;
	private SpinnerAdapter serverAdapter;
	private SpinnerAdapter payloadAdapter;
	public static SharedPreferences sharedPreferences;
	public static final String PASSWORD = new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)86,(char)49,(char)104,(char)119,(char)83,(char)49,(char)77,(char)121,(char)86,(char)108,(char)74,(char)81,(char)86,(char)68,(char)65,(char)57}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT));
	@SuppressLint("StaticFieldLeak")
	private static Spinner serverCategory;
	private Settings mConfig;
	public static SpaceNavigationView spaceNavigationView;
	public static BottomSheetBehavior<View> mBehavior;
	public TextView status;
	public static SwitchButton customSwitch;
	private SharedPreferences.Editor editor;
	private Button mButtonSet;
	private SweetAlertDialog nops;
	private CountDownTimer mCountDownTimer;
	private boolean mTimerRunning;
	private long saved_ads_time;
	private long mTimeLeftInMillis;
	private long mTimeLeftBtn;
	private TextView mTextViewCountDown;
	private boolean mTimerEnabled;
	private CountDownTimer mBtnCountDown;
	//ads google
	private static final String Inters = new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)87,(char)84,(char)74,(char)70,(char)100,(char)70,(char)108,(char)89,(char)81,(char)110,(char)100,(char)77,(char)87,(char)69,(char)73,(char)120,(char)87,(char)87,(char)107,(char)119,(char)78,(char)69,(char)53,(char)69,(char)85,(char)84,(char)78,(char)78,(char)86,(char)69,(char)108,(char)53,(char)84,(char)87,(char)112,(char)106,(char)77,(char)85,(char)53,(char)54,(char)97,(char)51,(char)108,(char)79,(char)82,(char)71,(char)99,(char)119,(char)84,(char)72,(char)112,(char)74,(char)78,(char)85,(char)53,(char)113,(char)81,(char)84,(char)82,(char)80,(char)82,(char)69,(char)107,(char)121,(char)84,(char)88,(char)112,(char)82,(char)80,(char)81,(char)61,(char)61}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT));
	private InterstitialAd interstitialAd;
	private static final String THEME_PREF = "theme_pref";
	private static final String THEME_MODE = "theme_mode";
	boolean isLoading;
	private RewardedAd rewardedAd;

	private static final String AD_UNIT_ID = new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)87,(char)84,(char)74,(char)70,(char)100,(char)70,(char)108,(char)89,(char)81,(char)110,(char)100,(char)77,(char)87,(char)69,(char)73,(char)120,(char)87,(char)87,(char)107,(char)119,(char)78,(char)69,(char)53,(char)69,(char)85,(char)84,(char)78,(char)78,(char)86,(char)69,(char)108,(char)53,(char)84,(char)87,(char)112,(char)106,(char)77,(char)85,(char)53,(char)54,(char)97,(char)51,(char)108,(char)79,(char)82,(char)71,(char)99,(char)119,(char)84,(char)72,(char)112,(char)70,(char)77,(char)69,(char)57,(char)85,(char)81,(char)84,(char)78,(char)80,(char)82,(char)70,(char)69,(char)121,(char)84,(char)107,(char)82,(char)66,(char)80,(char)81,(char)61,(char)61}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT));

	//salvar posição spinner e atualizar quando trocar de server
	private boolean isV2Ray = false;
	boolean spinnerTouched = false;
	@SuppressLint("StaticFieldLeak")
	private  static CheckBox wacke;
	private LogsAdapter mAdapter;

	public MainActivity() {
	}

	private int getBuildId(Context context) throws IOException {
		try {
			PackageInfo pinfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
			return pinfo.versionCode;
		} catch (PackageManager.NameNotFoundException e) {
			throw new IOException("Build ID not found");
		}
	}
	@SuppressLint({"MissingInflatedId", "UnspecifiedRegisterReceiverFlag"})
	@Override
	protected void onCreate(@Nullable Bundle savedInstanceState){
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		SharedPreferences prefs1 = getSharedPreferences(THEME_PREF, MODE_PRIVATE);
		int savedThemeMode = prefs1.getInt(THEME_MODE, -1);
		if (savedThemeMode != -1) {
			AppCompatDelegate.setDefaultNightMode(savedThemeMode);
		}
		setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
		checkUpdate(true);
		sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
		mainViewModel = ViewModelProviders.of(this).get(MainViewModel.class);
		adapter = new MainRecyclerAdapter(this);
		mHandler = new Handler();
		MobileAds.initialize(this, new OnInitializationCompleteListener() {
			@Override
			public void onInitializationComplete(InitializationStatus initializationStatus) {
				SkStatus.logInfo("<b><font color=\"#3b83bd\">Ads SDK Initialized</font></b>");
			}
		});
		IntentFilter filter = new IntentFilter();
		filter.addAction(UPDATE_VIEWS);
		LocalBroadcastManager.getInstance(this).registerReceiver(mActivityReceiver, filter);
		mConfig = new Settings(this);
		SkStatus.addStateListener(this);
		ReviewManager manager = ReviewManagerFactory.create(this);
		Task<ReviewInfo> request = manager.requestReviewFlow();
		request.addOnCompleteListener(task -> {
			if (task.isSuccessful()) {
				ReviewInfo reviewInfo = task.getResult();
				Task<Void> flow = manager.launchReviewFlow(this, reviewInfo);
				flow.addOnCompleteListener(task2 -> {
				});
			}
		});
		this.mStartRX = TrafficStats.getTotalRxBytes();
		long totalTxBytes = TrafficStats.getTotalTxBytes();
		this.mStartTX = totalTxBytes;
		if (this.mStartRX != -1 && totalTxBytes != -1) {
			this.mHandler2.postDelayed(this.mRunnable, 1000);
		}
		Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler(this));
		doLayout();
		mHandler = new Handler();
		IntentFilter intentFilter = new IntentFilter();
		intentFilter.addAction(UPDATE_VIEWS);
		intentFilter.addAction(OPEN_LOGS);
		LocalBroadcastManager.getInstance(this).registerReceiver(mActivityReceiver, intentFilter);
		loadAds();
		loadInterstitial = true;
		SharedPreferences prefs = getSharedPreferences("GERAL", Context.MODE_PRIVATE);
		int lastVersion = prefs.getInt("last_version", 0);

		try {
			int idAtual = getBuildId(this);

			if (lastVersion < idAtual) {
				if (lastVersion != 0) {
					ShowMsgUpdate();
				} else if (lastVersion == 0) {
					SharedPreferences.Editor editor = prefs.edit();
					editor.putInt("last_version", idAtual);
					editor.apply();
				}

			}
		} catch (IOException e) {
		}

		ConsentRequestParameters params = new ConsentRequestParameters
        .Builder()
        .setTagForUnderAgeOfConsent(false)
        .build();

		consentInformation = UserMessagingPlatform.getConsentInformation(this);
		consentInformation.requestConsentInfoUpdate(
				this,
				params,
				new ConsentInformation.OnConsentInfoUpdateSuccessListener() {
					@Override
					public void onConsentInfoUpdateSuccess() {
						if (consentInformation.isConsentFormAvailable()) {
							loadForm();
						}
					}
				},
                formError -> {
                    // Handle the error.
                });

		if (Build.VERSION.SDK_INT > 32) {
			if (!shouldShowRequestPermissionRationale("112")){
				getNotificationPermission();
			}
		}
		serverSpinner = findViewById(R.id.serverSpinner);
		payloadSpinner = findViewById(R.id.ispSpinner);
		textstatus = findViewById(R.id.textonline);
		serverList = new ArrayList<>();
		payloadList = new ArrayList<>();
		status = findViewById(R.id.conectionstatus);
		serverAdapter = new SpinnerAdapter(this, R.id.serverSpinner, serverList);
		payloadAdapter = new SpinnerAdapter(this, R.id.ispSpinner, payloadList);

		wacke = findViewById(R.id.usewacke);
		wacke.setChecked(prefs.getBoolean(Settings.WAKELOCK, true));
		wacke.setOnCheckedChangeListener((buttonView, isChecked) -> {
            if (wacke.isChecked()) {
                prefs.edit().putBoolean(Settings.WAKELOCK, true).apply();
            } else {
                prefs.edit().putBoolean(Settings.WAKELOCK, false).apply();
            }
        });

		serverSpinner.setAdapter(serverAdapter);
		payloadSpinner.setAdapter(payloadAdapter);
		mTextViewCountDown = findViewById(R.id.tvTimeRemaining);

		mButtonSet = findViewById(R.id.btnAddTime);
		mButtonSet.setOnClickListener(v -> verAds());

		serverSpinner.setOnTouchListener(new View.OnTouchListener() {
			@SuppressLint("ClickableViewAccessibility")
			@Override
			public boolean onTouch(View v, MotionEvent event) {

				if (event.getAction() == MotionEvent.ACTION_DOWN) {
					spinnerTouched = true; // User DID touched the spinner!
				}

				return false;
			}
		});
		final SharedPreferences prefsave = mConfig.getPrefsPrivate();

		serverSpinner.setSelection(prefsave.getInt("LastSelectedServer", 0));
		serverSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){

			@Override
			public void onItemSelected(AdapterView<?> p1, View p2, int p3, long p4) {
				SharedPreferences prefs = mConfig.getPrefsPrivate();
				SharedPreferences.Editor edit = prefs.edit();
				edit.putInt("LastSelectedServer", p3).apply();
				if (spinnerTouched) {
					checkServerStatus();
				}
			}

			@Override
			public void onNothingSelected(AdapterView<?> p1) {

			}
		});
		payloadSpinner.setSelection(prefsave.getInt("LastSelectedPayload", 0));
		payloadSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){

			@Override
			public void onItemSelected(AdapterView<?> p1, View p2, int p3, long p4) {
				SharedPreferences prefs = mConfig.getPrefsPrivate();
				SharedPreferences.Editor edit = prefs.edit();
				edit.putInt("LastSelectedPayload", p3).apply();
			}

			@Override
			public void onNothingSelected(AdapterView<?> p1) {
			}
		});

		customSwitch = findViewById(R.id.custom_switch);
		customSwitch.setChecked(sharedPreferences.getBoolean("isCustom", false));
		customSwitch.setOnCheckedChangeListener((view, isChecked) -> {
            sharedPreferences.edit().putBoolean("isCustom", isChecked).apply();
            payloadSpinner.setEnabled(!isChecked);
            if (isChecked) {
                new CustomDialog(MainActivity.this, sharedPreferences, (dialogInterface, i) -> {
                    sharedPreferences.edit().putBoolean("isCustom", false).apply();
                    customSwitch.setChecked(false);
                    payloadSpinner.setEnabled(true);
                });
            }
        });

		if (sharedPreferences.getBoolean("isCustom", false)) {
			payloadSpinner.setEnabled(false);
		}

		loadServer(sharedPreferences.getInt("Categories", 0));
		loadNewNetwork(sharedPreferences.getInt("Categories", 0));
		serverCategory = (Spinner) findViewById(R.id.serverType);
		List<String> category = new ArrayList<String>();
		/**category.add("");
		category.add("");**/
		ArrayAdapter<String> typeAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, category);

		typeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		serverCategory.setAdapter(typeAdapter);
		serverCategory.setSelection(sharedPreferences.getInt("Categories", 0));
		serverCategory.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener(){
			@Override
			public void onNothingSelected(AdapterView<?> p1) {
				// TODO: Implement this method
			}

			@Override
			public void onItemSelected(AdapterView<?> p1, View p2, int position, long p4) {
				try {
					sharedPreferences.edit().putInt("Categories", position).apply();
					loadServer(position);
					loadNewNetwork(position);
					doUpdateLayout();

				}
				catch (Exception e) {

				}
			}

		});

		checkServerStatus();
		doLoad();
		setupViewModelObserver();
		findViewById(R.id.status).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View view) {
				statusDialog();
			}
		});
		FrameLayout frameLayout = findViewById(R.id.adView);
		AdView adView = new AdView(this);
		// Define o tamanho do anúncio como responsivo
		AdSize adSize = getAdSize();
		adView.setAdSize(adSize);
		adView.setAdUnitId("ca-app-pub-8447122275792484/9526290980");
		frameLayout.addView(adView);
		if (TunnelUtils.isNetworkOnline(this)) {
			adView.setAdListener(new AdListener() {
				@Override
				public void onAdLoaded() {
					adView.setVisibility(View.VISIBLE);
				}
			});
			AdRequest adRequest = new AdRequest.Builder().build();
			adView.loadAd(adRequest);
		}

		spaceNavigationView = (SpaceNavigationView) findViewById(R.id.space);
		spaceNavigationView.addSpaceItem(new SpaceItem("", R.drawable.ic_update));
		spaceNavigationView.addSpaceItem(new SpaceItem("", R.drawable.wifi));
		spaceNavigationView.addSpaceItem(new SpaceItem("", R.drawable.ic_clean));
		spaceNavigationView.addSpaceItem(new SpaceItem("", R.drawable.cmd_menu));
		spaceNavigationView.shouldShowFullBadgeText(false);
		spaceNavigationView.setCentreButtonIconColorFilterEnabled(false);
		spaceNavigationView.setSpaceOnClickListener(new SpaceOnClickListener() {
			@Override
			public void onCentreButtonClick()
			{
				start();
				spaceNavigationView.shouldShowFullBadgeText(true);
				loadServerData();
				startOrStopTunnel(MainActivity.this);
			}

			@Override
			public void onItemClick(int itemIndex, String itemName)
			{
				manageClick(itemIndex);
			}

			@Override
			public void onItemReselected(int itemIndex, String itemName)
			{
				manageClick(itemIndex);
			}
		});

		@SuppressLint("ResourceType") View bottomSheet = new BottomSheetBuilder(this, (CoordinatorLayout) findViewById(R.id.coordLayout))
				.setMode(BottomSheetBuilder.MODE_GRID)
				//.addTitleItem("SSHBRASILOFICIAL!")
				.setBackgroundColorResource(R.color.colorAccent)
				.setItemTextColor(Color.parseColor(getString(R.color.bg_screen1)))
				//.setTitleTextColorResource(Color.parseColor(getString(R.color.colorAccent)))
				.setIconTintColor(Color.parseColor(getString(R.color.bg_screen2)))
				.setMenu(R.menu.menu_bottom_sheet)
				.setItemClickListener(new BottomSheetItemClickListener() {
					@Override
					public void onBottomSheetItemClick(MenuItem item)
					{

						// TODO: Implement this method
						mBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED);
						switch (item.getItemId())
						{
							case R.id.changelogs:
								showReleaseNotesDialog();
								break;

							case R.id.contact:
								String str = "http://sshbrasil.com.br";
								try
								{
									Intent cintent = new Intent("android.intent.action.VIEW", Uri.parse(str));
									startActivity(cintent);

								}
								catch (Exception e)
								{
									Intent cintent = new Intent("android.intent.action.VIEW", Uri.parse(str));
									startActivity(cintent);
								}
								break;
							case R.id.about:
								Intent abt = new Intent(MainActivity.this, AboutActivity.class);
								startActivity(abt);
								break;
							case R.id.exitme:
								Intent intentSettings = new Intent(MainActivity.this, ConfigGeralActivity.class);
								startActivity(intentSettings);
								break;


						}
					}
				})
				.createView();
		mBehavior = BottomSheetBehavior.from(bottomSheet);
		mBehavior.setBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() {
			@Override
			public void onStateChanged(@NonNull View bottomSheet, int newState)
			{
				if (newState == BottomSheetBehavior.STATE_COLLAPSED)
				{
					//fab.show();
				}
			}

			@Override
			public void onSlide(@NonNull View bottomSheet, float slideOffset)
			{

			}
		});

		PackageInfo pinfo = Utils.getAppInfo(this);
		if (pinfo != null) {
			String version_nome = pinfo.versionName;
			int version_code = pinfo.versionCode;
			@SuppressLint("DefaultLocale") String versionText = String.format("%s (%d)", version_nome, version_code);
			TextView app_info_text = findViewById(R.id.appVersion);
			SpannableStringBuilder builder = new SpannableStringBuilder();
			SpannableString versionLabel = new SpannableString("Versão: ");
			versionLabel.setSpan(new ForegroundColorSpan(Color.WHITE), 0, versionLabel.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
			builder.append(versionLabel);
			builder.append(versionText);
			app_info_text.setText(builder);
		}

	}

	private void setupViewModelObserver() {

		mainViewModel.getUpdateListAction().observe(this, new Observer() {
			public void onChanged(Object var1) {
				this.onChanged((Integer) var1);
			}

			public void onChanged(@Nullable Integer it) {
				if (it != null) {
					int index = it;
					if (index >= 0) {
						adapter.updateSelectedItem(index);
					} else {
						adapter.updateConfigList();
					}
				}
			}
		});

		mainViewModel.isRunning().observe(this, new Observer() {
			public void onChanged(Object var1) {
				this.onChanged((Boolean) var1);
			}

			public void onChanged(@Nullable Boolean it) {
				if (it != null) {
					boolean isRunning = it;
					adapter.setChangeable(!isRunning);
					if (isRunning) {
						SkStatus.updateStateString(SkStatus.SSH_CONNECTED, "Conectado");
						status.setTextColor(Color.GREEN);
					}
				}
			}
		});
		mainViewModel.startListenBroadcast();
	}

	/**
 	* Inicio adicionar tempo
 	*/

	@SuppressLint("MissingPermission")
	private void disconnected() {
		long[] vb = {0, 100, 100, 100};
		Vibrator vb_service = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
		vb_service.vibrate(vb, -1);
	}

	private void showInterstitial() {
		if (interstitialAd != null) {
			interstitialAd.show(this);
		}
	}

	private void loadAd() {
		AdRequest adRequest = new AdRequest.Builder().build();
		com.google.android.gms.ads.interstitial.InterstitialAd.load(this, Inters, adRequest,
				new InterstitialAdLoadCallback() {
					@Override
					public void onAdLoaded(@NonNull com.google.android.gms.ads.interstitial.InterstitialAd interstitialAd) {
						MainActivity.this.interstitialAd = interstitialAd;
						interstitialAd.setFullScreenContentCallback(
								new FullScreenContentCallback() {
									@Override
									public void onAdDismissedFullScreenContent() {
										MainActivity.this.interstitialAd = null;
										MDToast.makeText(MainActivity.this, "Obrigado por apoiar nosso app ❤\uFE0F", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS).show();
									}

									@Override
									public void onAdFailedToShowFullScreenContent(AdError adError) {
										MainActivity.this.interstitialAd = null;
									}

									@Override
									public void onAdShowedFullScreenContent() {
										// Este método é chamado quando o anúncio é mostrado.
									}
								});
					}

					@Override
					public void onAdFailedToLoad(@NonNull LoadAdError loadAdError) {
						interstitialAd = null;
					}
				});
	}

	private static final long MAX_TIME_MILLIS = 24 * 60 * 60 * 1000; // 24 horas em milissegundos

	private void verAds() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.addtime1);
		pDialog.setTitleText("OLÁ, USUÁRIO \uD83D\uDE4B");
		pDialog.setSecondTitleText("ASSISTA O ANUNCIO E GANHE 2 HORAS");
		pDialog.setContentText("Necessário conexão com internet.");
		pDialog.setConfirmText("Assistir");
		pDialog.setConfirmClickListener(sweetAlertDialog -> {
			loadRewardedAd();
			pDialog.dismiss();
		});

		pDialog.setCancelText("Fechar");
		pDialog.setCancelClickListener(sweetAlertDialog -> pDialog.dismiss());

		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);

		pDialog.show();
	}

	private void loadRewardedAd() {
		onRewardedVideoAdLoaded();
		if (rewardedAd == null) {
			isLoading = true;
			AdRequest adRequest = new AdRequest.Builder().build();
			RewardedAd.load(
					this,
					AD_UNIT_ID, adRequest,
					new RewardedAdLoadCallback() {
						@Override
						public void onAdFailedToLoad(@NonNull LoadAdError loadAdError) {
							rewardedAd = null;
							nops.dismiss();
							MDToast mdToast = MDToast.makeText(MainActivity.this, "Erro, verifique sua conexão com a internet !", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);
							mdToast.show();
						}

						@Override
						public void onAdLoaded(@NonNull RewardedAd rewardedAd) {
							MainActivity.this.rewardedAd = rewardedAd;
							MainActivity.this.isLoading = false;
							nops.dismiss();
							showAdLoadedDialog();
						}
					});
		}
	}

	private void showAdLoadedDialog() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.checkmark);
		pDialog.setTitleText("ANÚNCIO CARREGADO \uD83C\uDF89");
		pDialog.setSecondTitleText("Anúncio pronto para ser exibido");
		pDialog.setConfirmText("VER ANÚNCIO");
		pDialog.setConfirmClickListener(sweetAlertDialog -> {
			showRewardedVideo();
			pDialog.dismissWithAnimation();
		});
		pDialog.setCancelable(false);
		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
	}

	private void onRewardedVideoAdLoaded() {
		nops = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);
		nops.setTitleText("OBTENDO ANUNCIO, AGUARDE");
		nops.setSecondTitleText("Pode demorar um pouco");
		nops.setCancelable(true);
		Objects.requireNonNull(nops.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		nops.show();
	}

	private void showRewardedVideo() {
		if (rewardedAd == null) {
			return;
		}
		rewardedAd.setFullScreenContentCallback(
				new FullScreenContentCallback() {
					@Override
					public void onAdShowedFullScreenContent() {
					}

					@Override
					public void onAdFailedToShowFullScreenContent(AdError adError) {
						nops.dismiss();
						rewardedAd = null;
						MDToast mdToast = MDToast.makeText(MainActivity.this, "Erro ao carregar anuncio", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);
						mdToast.show();
					}

					@Override
					public void onAdDismissedFullScreenContent() {
						rewardedAd = null;
						btnTimer();
						nops.dismiss();
					}
				});
		Activity activityContext = this;
		rewardedAd.show(
				activityContext,
				rewardItem -> {
					btnTimer(); // Atualiza o botão
					long ads_time = 1000 * 60 * 60 * 2; // Adiciona 2 horas
					addTime(ads_time); // Adiciona o tempo
					nops.dismiss();
					MDToast mdToast = MDToast.makeText(MainActivity.this, "2 horas adicionadas com sucesso", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS);
					mdToast.show();
				});
	}

	private void start() {
		if (saved_ads_time == 0) {
			long initialTime = 6 * 60 * 1000 + 15 * 1000; // 6 minutos e 15 segundos em milissegundos
			setTime(initialTime);
		}

		if (!mTimerRunning) {
			startTimer();
		}
	}

	private void stop() {
		if (mTimerRunning) {
			pauseTimer();
		}
	}

	private void addTime(long time) {
		if (mTimeLeftInMillis + time <= MAX_TIME_MILLIS) {
			setTime(time);

			if (mTimerRunning) {
				pauseTimer();
			}

			startTimer();
		} else {
			// Exibe um diálogo de erro se exceder o limite de 24 horas
			show24HourLimitDialog();
		}
	}

	// Exibe um diálogo informando que o limite de 24 horas foi atingido
	private void show24HourLimitDialog() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.horas);
		pDialog.setTitleText("LIMITE DE 24H ATINGIDO!");
		pDialog.setContentText("Você atingiu o limite máximo de 24 horas.");
		pDialog.setConfirmText("OK");
		pDialog.setCancelable(false);
		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
	}

	private void pauseTimer() {
		mCountDownTimer.cancel();
		mTimerRunning = false;
	}

	// Lida com o término do temporizador
	@SuppressLint("SetTextI18n")
	private void handleTimerFinish() {
		// Lógica para quando o temporizador chega ao fim, como parar serviços ou atualizar UI
		if (Boolean.TRUE.equals(mainViewModel.isRunning().getValue())) {
			com.technore.v2ray.util.Utils.INSTANCE.stopVService(MainActivity.this);
			SkStatus.updateStateString(SkStatus.SSH_DISCONNECTED, getString(R.string.state_disconnected));
			statusconenect.setText("Desconectado");
			status.setTextColor(Color.RED);
			disconnected();
		} else {
			// Código para parar VPN automaticamente
			Intent stopVPN = new Intent(SSHService.TUNNEL_SSH_STOP_SERVICE);
			LocalBroadcastManager.getInstance(MainActivity.this).sendBroadcast(stopVPN);
			disconnected();
		}
		showTimeExpiredDialog();
	}

	// Exibe um diálogo informando que o tempo expirou
	private void showTimeExpiredDialog() {
		if (!isFinishing()) {
			pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
			Drawable drawable = ContextCompat.getDrawable(this, R.drawable.tempoesgotado);
			pDialog.setTitleText("TEMPO ESGOTADO");
			pDialog.setSecondTitleText("NÃO FIQUE SEM CONEXÃO");
			pDialog.setContentText("Adicione mais tempo.");
			pDialog.setCustomImage(drawable);
			pDialog.setConfirmText("OK");
			pDialog.setCancelable(false);
			pDialog.show();
		}
	}

	private void updateCountDownText() {
		long days = TimeUnit.MILLISECONDS.toDays(mTimeLeftInMillis);
		long daysMillis = TimeUnit.DAYS.toMillis(days);

		long hours = TimeUnit.MILLISECONDS.toHours(mTimeLeftInMillis - daysMillis);
		long hoursMillis = TimeUnit.HOURS.toMillis(hours);

		long minutes = TimeUnit.MILLISECONDS.toMinutes(mTimeLeftInMillis - daysMillis - hoursMillis);
		long minutesMillis = TimeUnit.MINUTES.toMillis(minutes);

		long seconds = TimeUnit.MILLISECONDS.toSeconds(mTimeLeftInMillis - daysMillis - hoursMillis - minutesMillis);

		String timeLeftFormatted = days > 0
				? String.format(Locale.getDefault(), "%d d %02d:%02d:%02d", days, hours, minutes, seconds)
				: String.format(Locale.getDefault(), "%02d:%02d:%02d", hours, minutes, seconds);

		mTextViewCountDown.setText(timeLeftFormatted);
	}

	private void setTime(long milliseconds) {
		saved_ads_time = mTimeLeftInMillis + milliseconds;
		mTimeLeftInMillis = saved_ads_time;
		updateCountDownText();
	}

	private void saveTime() {
		SharedPreferences saved_current_time = getSharedPreferences("time", Context.MODE_PRIVATE);
		SharedPreferences.Editor time_edit = saved_current_time.edit();
		time_edit.putLong("SAVED_TIME", mTimeLeftInMillis);
		time_edit.apply();
	}

	private void resumeTime() {
		SharedPreferences time = getSharedPreferences("time", Context.MODE_PRIVATE);
		long saved_time = time.getLong("SAVED_TIME", 0);
		setTime(saved_time);

		String state = SkStatus.getLastState();

		if (SkStatus.SSH_CONNECTED.equals(state)) {
			if (!mTimerRunning) {
				startTimer();
			}
		}
		mTimerEnabled = true;
	}

	private void startTimer() {
		if (mCountDownTimer != null) {
			mCountDownTimer.cancel(); // Evita múltiplas instâncias do Timer.
		}

		long endTime = System.currentTimeMillis() + mTimeLeftInMillis;

		mCountDownTimer =
				new CountDownTimer(mTimeLeftInMillis, 1000) {
					@Override
					public void onTick(long millisUntilFinished) {
						mTimeLeftInMillis = millisUntilFinished;
						saveTime();
						updateCountDownText();
					}

					@Override
					public void onFinish() {
						mTimerRunning = false;
						saved_ads_time = 0;
						handleTimerFinish();
					}
				};

		mCountDownTimer.start();
		mTimerRunning = true; // Corrigido o erro de atribuição
	}

	private void btnTimer() {
		// Cancela a contagem regressiva atual se estiver em andamento
		if (mBtnCountDown != null) {
			mBtnCountDown.cancel();
		}

		// Inicia uma nova contagem regressiva de 10 segundos
		mBtnCountDown = new CountDownTimer(10000, 1000) {
			@Override
			public void onTick(long millisUntilFinished) {
				mTimeLeftBtn = millisUntilFinished;
				mButtonSet.setEnabled(false);
				updateBtnText();
			}

			@Override
			public void onFinish() {
				mButtonSet.setEnabled(true);
				mButtonSet.setText("+ 120 MINUTOS");
			}
		}.start();
	}

	private void updateBtnText() {
		int seconds = (int) (mTimeLeftBtn / 1000) % 60;
		String timeLeftFormatted;
		if (seconds >= 0) {
			timeLeftFormatted = String.format(Locale.getDefault(), "%02d", seconds);
			mButtonSet.setText("Aguarde " + timeLeftFormatted);
		}
	}

// O método showSuccessDialogIfNeeded() foi removido

	private String formatTime(long millis) {
		long minutes = TimeUnit.MILLISECONDS.toMinutes(millis) % 60;
		long seconds = TimeUnit.MILLISECONDS.toSeconds(millis) % 60;

		// Formata o tempo restante em horas, minutos e segundos
		return String.format(Locale.getDefault(), " %02dm %02ds.", minutes, seconds);
	}

	public static void doUpdateLayout() {
		boolean isRunning = SkStatus.isTunnelActive();
		serverSpinner.setEnabled(!isRunning);
		wacke.setEnabled(!isRunning);
		if (!sharedPreferences.getBoolean("isCustom", false)) {
			payloadSpinner.setEnabled(!isRunning);
		}
		serverCategory.setEnabled(!isRunning);
		//switchButton.setEnabled(!isRunning);
		if(isRunning){

			spaceNavigationView.changeCenterButtonIcon(R.drawable.ic_close_white_24dp);
		}else{
			spaceNavigationView.changeCenterButtonIcon(R.drawable.ic_paper_plane);
		}
	}

	void manageClick(int itemIndex)
	{
		switch (itemIndex)
		{
			case 0:
				checkUpdate(false);
				break;

			case 1:
				Intent ab = new Intent(this, ProxySettings.class);
				startActivity(ab);
				break;

			case 2:
				clearAppData();
				break;
			case 3:
				mBehavior.setState(BottomSheetBehavior.STATE_EXPANDED);
				break;
		}
	}

	public void clear(){
		android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this, R.style.androidjc);
		builder.setTitle(this.getString(R.string.attention));
		builder.setMessage(this.getString(R.string.alert_clear_settings));
		builder.setPositiveButton(this.getString(R.string.yes), new DialogInterface.OnClickListener() {
					@RequiresApi(api = Build.VERSION_CODES.M) // Ensure this is necessary
					@Override
					public void onClick(DialogInterface dialog, int which) {
						Settings.clearSettings(MainActivity.this);
						SkStatus.clearLog();
						updateMainViews(MainActivity.this);
					}
				});
		builder.setNegativeButton(this.getString(R.string.no), new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						dialog.dismiss();
					}
				});

		android.app.AlertDialog dialog = builder.create();
		dialog.show();
	}

	private int SelectAuto(){
		int pos2 = 0;
		try {
			ConnectivityManager connManager = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE);
			NetworkInfo mWifi = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
			NetworkInfo mMobile = connManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);

			if (mWifi.isConnected()) {
				pos2 = 0;
			} else if (mMobile.isConnected()) {
				NetworkInfo networkInfo = connManager.getActiveNetworkInfo();
				String Apntype = networkInfo.getExtraInfo();
				if (Apntype.contains("vivo")) {
					pos2 = 1;
				} else if (Apntype.contains("tim") || Apntype.contains("timbrasil")) {
					pos2 = 2;
				} else if (Apntype.contains("claro") || Apntype.contains("java")) {
					pos2 = 3;
				} else if (Apntype.contains("oi")) {
					pos2 = 4;
				} else {
					pos2 = 1;
				}
			}

		} catch (Exception e) {

		}
		return pos2;
	}

	private void loadAutoData(){
		try {
			SharedPreferences prefs = mConfig.getPrefsPrivate();
			SharedPreferences.Editor edit = prefs.edit();

			int pos1 = serverSpinner.getSelectedItemPosition();
			String name = getServersArray().getJSONObject(pos1).getString("Name");
			String ssh_server = getServersArray().getJSONObject(pos1).getString("ServerIP");
			String ssh_port = getServersArray().getJSONObject(pos1).getString("ServerPort");
			String sslPort = getServersArray().getJSONObject(pos1).getString("sslPort");
			String cloud_front = getServersArray().getJSONObject(pos1).getString("CloudFrontIP");
			String User = getServersArray().getJSONObject(pos1).getString("User");
			String Pass = getServersArray().getJSONObject(pos1).getString("Pass");
			/**String pubKey = getServersArray().getJSONObject(pos1).getString("pubKey");
			// String dnsIP = getServersArray().getJSONObject(pos1).getString("dnsIP");
			// edit.putString(Settings.SLOW_CHAVE_KEY, pubKey);
			//edit.putString(Settings.SLOW_NAMESERVER_KEY, dnsIP);**/

			int pos2 = SelectAuto();
			JSONObject obj = sharedPreferences.getBoolean("isCustom", false) ? new JSONObject(sharedPreferences.getString("Custom", "")) : getAutoPArray().getJSONObject(pos2);

			String payload = obj.optString("Payload");
			String sni = obj.optString("Sni");
			String tlsip = obj.optString("Tlsip");
			String tlsversao = obj.optString("tlsVersion");
			String proxyip = obj.optString("ProxyIP");
			String proxyport = obj.optString("ProxyPort");
			String CloudFront = obj.optString("CloudFront");
			String tunnelType = obj.optString("tunnelType");



			if (payload.contains("app_host")){
				payload = payload.replaceAll("app_host", ssh_server);
			}

			if (payload.contains("app_front")){
				payload = payload.replaceAll("app_front", cloud_front);
			}

			if (sni.contains("app_host")){
				sni = ssh_server;
			}

			if (tlsip.contains("app_host")){
				tlsip = ssh_server;
			}

			if (proxyip.contains("app_host")){
				proxyip = ssh_server;
			}

			if (proxyport.contains("app_port")){
				proxyport = "80";
			}

			if (CloudFront.contains("app_host")){
				CloudFront = cloud_front;
			}

			if (sharedPreferences.getBoolean("isCustom", false)) {
				tunnelType = tunnelType.equals("0") ? "2" : tunnelType.equals("1") ? "1" : "4";
			}

			isV2Ray = false;

			//prefs.getString(Settings.SLOW_DNS_IP_KEY, "");
			switch (tunnelType) {
				case "front": /*HTTP-CF*/
					edit.putString(Settings.SERVIDOR_KEY, CloudFront);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putString(Settings.PROXY_PORTA_KEY, proxyport);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_PROXY);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, payload).apply();
					break;

				case "ssl": /*SSL*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, sslPort);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSL);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.SNI_HOST_KEY, sni);
					edit.putString(Settings.TLS_VERSAO_KEY, tlsversao);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, "[]").apply();
					break;

				case "http": /*HTTP*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putString(Settings.PROXY_PORTA_KEY, proxyport);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_PROXY);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY,payload).apply();
					break;

				case "direct": /*DIRECT*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_DIRECT);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, payload);
					break;

				case "sslpay": /*SSL + PAY*/
					edit.putString(Settings.SERVIDOR_KEY,tlsip).apply();
					edit.putString(Settings.SERVIDOR_PORTA_KEY, sslPort);
					edit.putString(Settings.PROXY_PORTA_KEY, sslPort);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_PAY_SSL);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY,payload );
					edit.putString(Settings.SNI_HOST_KEY, sni).apply();
					edit.putString(Settings.TLS_VERSAO_KEY, tlsversao);
					break;

				case "v2ray": /*V2RAY*/
					if (mainViewModel.getServerList().size() > 0) {
						mainViewModel.removeServer(mainViewModel.getServerList().get(0));
					}
					isV2Ray = true;
					if (V2ConfigManager.INSTANCE.importBatchConfig(obj.optString("V2Ray"), "") > 0) {
						mainViewModel.reloadServerList();
					}
					break;

			}
			edit.putBoolean(Settings.IS_PASS, getObjectBoolean("fbn"));
			edit.putInt("serverPreference",pos1);
			edit.putInt("ispPreference",pos2);
			edit.putString(Settings.USUARIO_KEY, User+new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)86,(char)109,(char)120,(char)83,(char)82,(char)49,(char)81,(char)120,(char)84,(char)108,(char)100,(char)83,(char)98,(char)107,(char)53,(char)85,(char)89,(char)84,(char)66,(char)119,(char)86,(char)49,(char)82,(char)86,(char)90,(char)68,(char)82,(char)85,(char)90,(char)122,(char)48,(char)57}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)));
			edit.putString(Settings.SENHA_KEY, Pass+new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)86,(char)109,(char)120,(char)111,(char)99,(char)49,(char)69,(char)120,(char)87,(char)107,(char)90,(char)105,(char)82,(char)86,(char)112,(char)104,(char)84,(char)87,(char)49,(char)83,(char)85,(char)49,(char)108,(char)87,(char)86,(char)107,(char)116,(char)87,(char)82,(char)107,(char)53,(char)87,(char)86,(char)109,(char)116,(char)97,(char)89,(char)85,(char)49,(char)87,(char)87,(char)84,(char)70,(char)86,(char)86,(char)51,(char)82,(char)51,(char)85,(char)50,(char)120,(char)75,(char)87,(char)86,(char)108,(char)54,(char)97,(char)122,(char)48,(char)61}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)));
			edit.apply();
		} catch (Exception e) {
			e.printStackTrace();
			SkStatus.logInfo("Erro");
		}

	}


	private void loadServerData() {
		try {
			SharedPreferences prefs = mConfig.getPrefsPrivate();
			SharedPreferences.Editor edit = prefs.edit();

			int pos1 = serverSpinner.getSelectedItemPosition();
			String name = getServersArray().getJSONObject(pos1).getString("Name");
			String ssh_server = getServersArray().getJSONObject(pos1).getString("ServerIP");
			String ssh_port = getServersArray().getJSONObject(pos1).getString("ServerPort");
			String sslPort = getServersArray().getJSONObject(pos1).getString("sslPort");
			String cloud_front = getServersArray().getJSONObject(pos1).getString("CloudFrontIP");
			String User = getServersArray().getJSONObject(pos1).getString("User");
			String Pass = getServersArray().getJSONObject(pos1).getString("Pass");
			/** String pubKey = getServersArray().getJSONObject(pos1).getString("pubKey");
			// String dnsIP = getServersArray().getJSONObject(pos1).getString("dnsIP");
			// edit.putString(Settings.SLOW_CHAVE_KEY, pubKey);
			//edit.putString(Settings.SLOW_NAMESERVER_KEY, dnsIP);**/

			int pos2 = payloadSpinner.getSelectedItemPosition();
			JSONObject obj = getNetworksArray().getJSONObject(pos2);
			if (sharedPreferences.getBoolean("isCustom", false)){
				obj =new JSONObject( sharedPreferences.getString("Custom", ""));
			}
			String payload = obj.optString("Payload");
			String sni = obj.optString("Sni");
			String tlsversao = obj.optString("tlsVersion");
			String tlsip = obj.optString("Tlsip");
			String proxyip = obj.optString("ProxyIP");
			String proxyport = obj.optString("ProxyPort");
			String CloudFront = obj.optString("CloudFront");
			String tunnelType = obj.optString("tunnelType");


			if (tunnelType.contains("Auto")) {
				loadAutoData();
				return;
			}

			if (payload.contains("app_host")){
				payload = payload.replaceAll("app_host", ssh_server);
			}

			if (payload.contains("app_front")){
				payload = payload.replaceAll("app_front", cloud_front);
			}

			if (sni.contains("app_host")){
				sni = ssh_server;
			}

			if (tlsip.contains("app_host")){
				tlsip = ssh_server;
			}

			if (proxyip.contains("app_host")){
				proxyip = ssh_server;
			}

			if (proxyport.contains("app_port")){
				proxyport = "80";
			}

			if (CloudFront.contains("app_host")){
				CloudFront = cloud_front;
			}


			isV2Ray = false;

			//prefs.getString(Settings.SLOW_DNS_IP_KEY, "");
			switch (tunnelType) {
				case "front": /*HTTP-CF*/
					edit.putString(Settings.SERVIDOR_KEY, CloudFront);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putString(Settings.PROXY_PORTA_KEY, proxyport);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_PROXY);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, payload).apply();
					break;

				case "ssl": /*SSL*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, sslPort);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSL);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.SNI_HOST_KEY, sni);
					edit.putString(Settings.TLS_VERSAO_KEY, tlsversao);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, "[]").apply();
					break;

				case "http": /*HTTP*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putString(Settings.PROXY_PORTA_KEY, proxyport);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_PROXY);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY,payload).apply();
					break;

				case "direct": /*DIRECT*/
					edit.putString(Settings.SERVIDOR_KEY, ssh_server);
					edit.putString(Settings.SERVIDOR_PORTA_KEY, ssh_port);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_SSH_DIRECT);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY, payload);
					break;

				case "sslpay": /*SSL + PAY*/
					edit.putString(Settings.SERVIDOR_KEY,tlsip).apply();
					edit.putString(Settings.SERVIDOR_PORTA_KEY, sslPort);
					edit.putString(Settings.PROXY_PORTA_KEY, sslPort);
					edit.putString(Settings.PROXY_IP_KEY, proxyip);
					edit.putInt(Settings.TUNNELTYPE_KEY, Settings.bTUNNEL_TYPE_PAY_SSL);
					edit.putBoolean(Settings.PROXY_USAR_DEFAULT_PAYLOAD, false);
					edit.putBoolean(Settings.SLOW_DNSKEY, false);
					edit.putString(Settings.CUSTOM_PAYLOAD_KEY,payload );
					edit.putString(Settings.SNI_HOST_KEY, sni).apply();
					edit.putString(Settings.TLS_VERSAO_KEY, tlsversao);
					break;

				case "v2ray": /*V2RAY*/
					if (mainViewModel.getServerList().size() > 0) {
						mainViewModel.removeServer(mainViewModel.getServerList().get(0));
					}
					isV2Ray = true;
					if (V2ConfigManager.INSTANCE.importBatchConfig(obj.optString("V2Ray"), "") > 0) {
						mainViewModel.reloadServerList();
					}
					break;

			}
			edit.putBoolean(Settings.IS_PASS, getObjectBoolean("fbn"));
			edit.putInt("serverPreference",pos1);
			edit.putInt("ispPreference",pos2);
			edit.putString(Settings.USUARIO_KEY, User+new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)86,(char)109,(char)120,(char)83,(char)82,(char)49,(char)81,(char)120,(char)84,(char)108,(char)100,(char)83,(char)98,(char)107,(char)53,(char)85,(char)89,(char)84,(char)66,(char)119,(char)86,(char)49,(char)82,(char)86,(char)90,(char)68,(char)82,(char)85,(char)90,(char)122,(char)48,(char)57}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)));
			edit.putString(Settings.SENHA_KEY, Pass+new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(android.util.Base64.decode(new String(new char[]{(char)86,(char)109,(char)120,(char)111,(char)99,(char)49,(char)69,(char)120,(char)87,(char)107,(char)90,(char)105,(char)82,(char)86,(char)112,(char)104,(char)84,(char)87,(char)49,(char)83,(char)85,(char)49,(char)108,(char)87,(char)86,(char)107,(char)116,(char)87,(char)82,(char)107,(char)53,(char)87,(char)86,(char)109,(char)116,(char)97,(char)89,(char)85,(char)49,(char)87,(char)87,(char)84,(char)70,(char)86,(char)86,(char)51,(char)82,(char)51,(char)85,(char)50,(char)120,(char)75,(char)87,(char)86,(char)108,(char)54,(char)97,(char)122,(char)48,(char)61}).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)).getBytes(), android.util.Base64.DEFAULT)));
			edit.apply();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void doLoad() {
		SharedPreferences prefs = mConfig.getPrefsPrivate();
		serverSpinner.setSelection(prefs.getInt("serverPreference",0));
		payloadSpinner.setSelection(prefs.getInt("ispPreference",0));
	}
	private void loadNewNetwork(int type) {
		try {
			if (payloadList.size() > 0) {
				payloadList.clear();
				payloadAdapter.notifyDataSetChanged();
			}

			//	ArrayList<JSONObject> listObject = new ArrayList<>();
			JSONArray prem = getNetPremiumArray();
			JSONObject objs = null;
            switch (type) {
				case 0:
					for (int i = 0; i < prem.length(); i++) {
						objs = prem.getJSONObject(i);
						//listObject.add(objs);
						payloadList.add(objs);
						payloadAdapter.notifyDataSetChanged();
					}
					break;

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	private void loadServer(int type) {
		try {
			if (serverList.size() > 0) {
				serverList.clear();
				serverAdapter.notifyDataSetChanged();
			}
			ArrayList<JSONObject> listObject = new ArrayList<>();
			JSONArray prem = getPremiumArray();
			JSONObject objs = null;
			if (listObject.size() > 0) {
				listObject.clear();
			}
			switch (type) {
				case 0:
					for (int i = 0; i < prem.length(); i++) {
						objs = prem.getJSONObject(i);
						listObject.add(objs);
						serverList.add(objs);
						serverAdapter.notifyDataSetChanged();
					}
					break;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void startOrStopTunnel(Activity activity) {

		int pos2 = payloadSpinner.getSelectedItemPosition();
		if (SkStatus.isTunnelActive()) {
			if (mainViewModel.isRunning().getValue()) {
				com.technore.v2ray.util.Utils.INSTANCE.stopVService(this);
				SkStatus.updateStateString(SkStatus.SSH_DISCONNECTED, getString(R.string.state_disconnected));
				statusconenect.setText("Desconectado");
				status.setTextColor(Color.RED);
				disconnected();
				return;
			}
			try {
				String tunnelType = getNetworksArray().getJSONObject(pos2).getString("tunnelType");
				switch (tunnelType) {
					case "Auto": /*AUTO*/
					case "front": /*HTTP_FRONT*/
					case "ssl": /*SSL*/
					case "http": /*HTTP*/
					case "direct": /*DIRECT*/
					case "sslpay": /*SSL + PAY*/
					case "v2ray": /*V2RAY*/
						TunnelManagerHelper.stopSocksHttp(activity);
						break;
				}
			}catch(Exception ignored){
			}
		} else {
			loadInterstitial = true;
			if (isV2Ray) {
				Intent intent = VpnService.prepare(this);
				if (intent != null) {
					startActivityForResult(intent, 2);
				} else {
					onActivityResult(2, RESULT_OK, null);
				}
				return;
			}
			Settings config = new Settings(activity);
			try {
				String tunnelType = getNetworksArray().getJSONObject(pos2).getString("tunnelType");
				switch (tunnelType) {
					case "Auto": /*AUTO*/
					case "front": /*HTTP_FRONT*/
					case "ssl": /*SSL*/
					case "http": /*HTTP*/
					case "direct": /*DIRECT*/
					case "sslpay": /*SSL + PAY*/
					case "v2ray": /*V2RAY*/
						Intent intent = new Intent(activity, LaunchVpn.class);
						intent.setAction(Intent.ACTION_MAIN);
						if (config.getHideLog()) {
							intent.putExtra(LaunchVpn.EXTRA_HIDELOG, true);
						}
						activity.startActivity(intent);
						break;
				}

			}catch(Exception ignored){
			}
		}
	}
	private BroadcastReceiver mActivityReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(Context context, Intent intent) {
			String action = intent.getAction();
			if (action == null)
				return;

			if (action.equals(UPDATE_VIEWS)) {
				doUpdateLayout();
			}

		}
	};

	public static void updateMainViews(Context context) {
		Intent updateView = new Intent(UPDATE_VIEWS);
		LocalBroadcastManager.getInstance(context).sendBroadcast(updateView);
	}

	//private ProfileManager getPM() { return ProfileManager.getInstance(this); }

	@Override
	public void onSaveInstanceState(Bundle outState)
	{
		super.onSaveInstanceState(outState);
		spaceNavigationView.onSaveInstanceState(outState);
	}

	private void clearAppData() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.atencao);
		pDialog.setTitleText(getString(R.string.attention));
		pDialog.setContentText(getString(R.string.alert_clear_settings));
		pDialog.setConfirmText(getString(R.string.yes));
		pDialog.setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				String packageName = getPackageName();
				Runtime runtime = Runtime.getRuntime();
				try {
					runtime.exec("pm clear " + packageName);
				} catch (IOException e) {
					e.printStackTrace();
				}
				sweetAlertDialog.dismissWithAnimation();
				// Reiniciar o aplicativo após limpar os dados
				Intent intent = new Intent(getApplicationContext(), MainActivity.class);
				intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
				startActivity(intent);
				finish();
			}
		});

		pDialog.setCancelText(getString(R.string.no));
		pDialog.setCancelClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				sweetAlertDialog.dismissWithAnimation();
			}
		});

		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);

		pDialog.show();
	}

    /**
	 * Drawer Main
	 */

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		super.onConfigurationChanged(newConfig);

	}

	private boolean loadInterstitial;
	@Override
	public void updateState(final String state, String msg, int localizedResId, final ConnectionStatus level, Intent intent) {
		mHandler.post(new Runnable() {
			@SuppressLint("SetTextI18n")
			@Override
			public void run() {
				doUpdateLayout();
				if (SkStatus.isTunnelActive()) {
					if (level.equals(ConnectionStatus.LEVEL_CONNECTED)) {
						status.setText("Conectado");
						status.setTextColor(Color.GREEN); // Define a cor do texto como verde
					}

					if (level.equals(ConnectionStatus.LEVEL_NOTCONNECTED)) {
						MDToast mdToast = MDToast.makeText(MainActivity.this, "Desconectado", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);
						mdToast.show();
						status.setText("Desconectado");
						status.setTextColor(Color.RED);
						stop();
					}
					if (level.equals(ConnectionStatus.LEVEL_CONNECTING_SERVER_REPLIED)) {
						status.setText("Autenticando");
						status.setTextColor(Color.parseColor("#FFFFFF"));
					}
					if (level.equals(ConnectionStatus.LEVEL_CONNECTING_NO_SERVER_REPLY_YET)) {
						status.setText("Conectando");
						status.setTextColor(Color.parseColor("#FFFFFF"));
					}

					if (level.equals(ConnectionStatus.LEVEL_AUTH_FAILED)) {
						// Tratamento para falha de autenticação
					}
					if (level.equals(ConnectionStatus.UNKNOWN_LEVEL)) {
						status.setText("Desconectado");
						status.setTextColor(Color.RED);
						stop();
					}
				}

				if (level.equals(ConnectionStatus.LEVEL_NONETWORK)) {
					MDToast mdToast = MDToast.makeText(MainActivity.this, "Sem rede movel :(", MDToast.LENGTH_SHORT, MDToast.TYPE_WARNING);
					mdToast.show();
					status.setText("Sem rede");
					status.setTextColor(Color.parseColor("#FFFFFF"));
				}

				if (state.equals(SkStatus.SSH_CONNECTED)) {
					mHandler.postDelayed(new Runnable() {
						@Override
						public void run() {
							if (loadInterstitial) {
								loadInterstitial = false;
								MDToast mdToast = MDToast.makeText(MainActivity.this, "Conectado com sucesso", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS);
								mdToast.show();
								loadAd();
								showInterstitial();
							}
						}
					}, 1000);
				}
			}
		});
	}

	private void checkUpdate(final boolean a) {
		new ConfigUpdate(this, new ConfigUpdate.OnUpdateListener() {
			@Override
			public void onUpdateListener(String result) {
				try {
					if (!result.contains("Erro ao obter dados")) {
						String json_data = AESCrypt.decrypt(PASSWORD, result);
						if (isNewVersion(json_data)) {
							newUpdateDialog(result);
						} else {
							if (!a) {
								noUpdateDialog();
							}
						}
					} else if(result.contains("Erro ao obter dados") && !a){
						errorUpdateDialog(result);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}).start(a);
	}

	private boolean isNewVersion(String result) {
		try {
			String current = getVersion();
			String update = new JSONObject(result).getString("Version");
			return versionCompare(update, current);
		} catch (JSONException e) {
			e.printStackTrace();
		}
		return false;
	}

	private void newUpdateDialog(final String result) throws JSONException, GeneralSecurityException {
		nops = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);
		nops.setTitleText("ATUALIZANDO CONFIGURAÇÕES");
		nops.setSecondTitleText("Aguarde a atualização");
		nops.setContentText("Duração maxima 5 Segundos");
		nops.setCancelable(true);
		Objects.requireNonNull(nops.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		nops.show();
		String json = AESCrypt.decrypt(PASSWORD, result);
		String Notes = new JSONObject(json).getString("ReleaseNotes");
		mHandler.postDelayed(new Runnable() {
			@Override
			public void run() {
				try {
					File file = new File(MainActivity.this.getFilesDir(), "Config.json");
					OutputStream out = new FileOutputStream(file);
					out.write(result.getBytes());
					out.flush();
					out.close();
					restart_app();
				} catch (IOException e) {
					e.printStackTrace();
				}

			}
		}, 3000);
	}

	private void restart_app() {
		Context context = this;
		PackageManager packageManager = context.getPackageManager();
		Intent intent = packageManager.getLaunchIntentForPackage(context.getPackageName());
		ComponentName componentName = intent.getComponent();
		Intent mainIntent = Intent.makeRestartActivityTask(componentName);
		context.startActivity(mainIntent);
		Runtime.getRuntime().exit(0);
	}

	private void showReleaseNotesDialog() {
		String releaseNotes = getChangelog();
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setTitleText("NOTAS DE ATUALIZAÇÕES");
		pDialog.setContentText(releaseNotes);
		Drawable drawable = ContextCompat.getDrawable(this, R.drawable.notes);
		pDialog.setCustomImage(drawable);
		pDialog.setConfirmText("OK");
		pDialog.setCancelable(false);
		pDialog.show();
	}


	private void noUpdateDialog() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.noatt);
		pDialog.setTitleText("SEM ATUALIZAÇÕES");
		pDialog.setContentText("Não foi encontrada nenhuma atualização");
		pDialog.setConfirmText("OK");
		pDialog.setCancelable(false);
		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
	}

	private void errorUpdateDialog(final String result) throws JSONException, GeneralSecurityException {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.erro);
		pDialog.setTitleText("ERRO NA ATUALIZAÇÃO");
		pDialog.setContentText("Verifique sua internet\n\nFaça conexão com nosso app\n\" ");
		pDialog.setConfirmText("OK");
		pDialog.setCancelable(false);
		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
		String json = AESCrypt.decrypt(PASSWORD, result);
		String Notes = new JSONObject(json).getString("ReleaseNotes");
		mHandler.postDelayed (new Runnable() {
			@Override
			public void run() {
				try {
					File file = new File(MainActivity.this.getFilesDir(), "Config.json");
					OutputStream out = new FileOutputStream(file);
					out.write(result.getBytes());
					out.flush();
					out.close();
					restart_app();
				} catch (IOException e) {
					e.printStackTrace();
				}

			}}, 5000);
	}

	/**
	 * Recebe locais Broadcast
	 */


	@Override
	public void onPause() {
		super.onPause();
		SkStatus.removeStateListener(this);
		unregisterReceiver(networkReceiver);

		// Salvar o tempo restante
		saveTime();
	}


	@RequiresApi(api = Build.VERSION_CODES.M)
	@Override
	public void onDestroy() {
		super.onDestroy();
		start();
		loadServerData();

		// Salvar o tempo restante
		saveTime();

		mAppUpdateManager.unregisterListener(installStateUpdatedListener);
		LocalBroadcastManager.getInstance(this).unregisterReceiver(mActivityReceiver);
	}

	@Override
	public void onStart(){
		super.onStart();
		doLoad();
	}
	public String getChangelog() {
		try {
			JSONObject config = getJSONConfig();
			return config.getString("ReleaseNotes");
		} catch (Exception e) {
			e.printStackTrace();
			return "No release notes available";
		}
	}
	public String getVersion() {
		try {
			String version = getJSONConfig().getString("Version");
			return version;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public JSONArray getPremiumArray() {
		try {
			if (getJSONConfig() != null) {
				JSONArray array = getJSONConfig().getJSONArray("Premium");
				return array;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public JSONArray getNetPremiumArray() {
		try {
			if (getJSONConfig() != null) {
				JSONArray array = getJSONConfig().getJSONArray("NetworksPremium");
				return array;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public JSONArray getAutoPArray() {
		try {
			if (getJSONConfig() != null) {
				JSONArray array = getJSONConfig().getJSONArray("NetworksAuto");
				return array;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public JSONArray getServersArray() {
		try {
			JSONArray array = null;
			if (getJSONConfig() != null) {
				switch (sharedPreferences.getInt("Categories", 0)) {
					case 0:
						array = getJSONConfig().getJSONArray("Premium");
						break;
				}
				return array;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	public Boolean getObjectBoolean(String i){
		try {
			Boolean b = getJSONConfig().getBoolean(i);
			return b;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return true;
	}


	public JSONArray getNetworksArray() {
		try {
			JSONArray array = null;
			if (getJSONConfig() != null) {
				switch (sharedPreferences.getInt("Categories", 0)) {
					case 0:
						array = getJSONConfig().getJSONArray("NetworksPremium");
						break;
				}
				return array;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;

	}

	public boolean versionCompare(String NewVersion, String OldVersion) {
		String[] vals1 = NewVersion.split("\\.");
		String[] vals2 = OldVersion.split("\\.");
		int i = 0;

		// set index to first non-equal ordinal or length of shortest version string
		while (i < vals1.length && i < vals2.length && vals1[i].equals(vals2[i])) {
			i++;
		}
		// compare first non-equal ordinal number
		if (i < vals1.length && i < vals2.length) {
			int diff = Integer.valueOf(vals1[i]).compareTo(Integer.valueOf(vals2[i]));
			return Integer.signum(diff) > 0;
		}

		// the strings are equal or one string is a substring of the other
		// e.g. "1.2.3" = "1.2.3" or "1.2.3" < "1.2.3.4"
		return Integer.signum(vals1.length - vals2.length) > 0;
	}

	private JSONObject getJSONConfig() {
		try {
			File file = new File(this.getFilesDir(), "Config.json");
			if (file.exists()) {
				String json_file = readStream(new FileInputStream(file));
				String json = AESCrypt.decrypt(PASSWORD, json_file);
				return new JSONObject(json);
			} else {
				InputStream inputStream = this.getAssets().open("config.json");
				String json = AESCrypt.decrypt(PASSWORD, readStream(inputStream));
				return new JSONObject(json);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

	private String readStream(InputStream in)
	{
		StringBuilder sb = new StringBuilder();
		try {
			Reader reader = new BufferedReader(new InputStreamReader(in));
			char[] buff = new char[1024];
			while (true) {
				int read = reader.read(buff, 0, buff.length);
				if (read <= 0) {
					break;
				}
				sb.append(buff, 0, read);
			}
		} catch (Exception e) {

		}
		return sb.toString();
	}
	private void statusDialog() {
		if (TunnelUtils.isNetworkOnline(this)) {
			pDialog = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);
			pDialog.setTitleText("Carregando Servidores!");
			Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
			pDialog.show();

			// Initialize the GETRequest
			GETRequest getRequest = new GETRequest(new GETRequest.GETRequestListener() {
				@SuppressLint("SetTextI18n")
				@Override
				public void onResponse(ArrayList<String> responseList) {
					pDialog.dismiss();
					loadAd();
					int total = 0;
					for (String str : responseList) {
						if (str.length() < 6) {
							str = str.replaceAll("[^0-9\\.]", "");
							if (!str.isEmpty()) {
								total += Integer.parseInt(str);
							}
						}
					}
					LinearLayout linearLayout = new LinearLayout(MainActivity.this);
					linearLayout.setOrientation(LinearLayout.VERTICAL);
					TextView textView = new TextView(linearLayout.getContext());
					textView.setText("Status Servidor");
					textView.setPadding(0, 24, 0, 16);
					textView.setGravity(Gravity.CENTER);
					textView.setBackgroundColor(getResources().getColor(R.color.colorAccent));
					textView.setAllCaps(true);
					textView.setTextColor(Color.WHITE);
					textView.setTextSize(16);
					textView.setTypeface(null, Typeface.BOLD);
					TextView textView2 = new TextView(linearLayout.getContext());
					textView2.setText(Html.fromHtml("<font color=#FFFFFF><b>Usuarios Online: </b></font>" + total));
					textView2.setPadding(0, 12, 0, 44);
					textView2.setGravity(Gravity.CENTER);
					textView2.setBackgroundColor(getResources().getColor(R.color.colorAccent));
					textView2.setTextColor(Color.GREEN);
					textView2.setTextSize(15);
					textView2.setTypeface(null, Typeface.BOLD);
					ListView listView = new ListView(MainActivity.this);
					listView.setDivider(null);
					listView.setAdapter(new ServerStatusAdapter(MainActivity.this, new ArrayList<>(serverList.subList(1, serverList.size())), responseList));
					linearLayout.addView(textView);
					linearLayout.addView(textView2);
					linearLayout.addView(listView);
					android.app.AlertDialog alertDialog = new android.app.AlertDialog.Builder(MainActivity.this,R.id.toolbar_main)
							.setPositiveButton("Atualizar", new DialogInterface.OnClickListener() {
								@Override
								public void onClick(DialogInterface dialogInterface, int i) {
									dialogInterface.dismiss();
									statusDialog();
								}
							})
							.setNegativeButton("Voltar", null).create();
					alertDialog.setView(linearLayout);
					alertDialog.show();
					loadAd();
					showInterstitial();
				}
			});

			// Skip the first server from the list
			if (serverList.size() > 1) {
				for (int i = 1; i < serverList.size(); i++) {
					JSONObject obj = serverList.get(i);
					getRequest.addAPI("http://" + obj.optString("ServerIP", "") + ":8888/server/online");
				}
			}

			// Start the GET request
			getRequest.start();
		} else {
			MDToast mdToast = MDToast.makeText(MainActivity.this, "Conectar a internet para ver servidores", MDToast.LENGTH_SHORT, MDToast.TYPE_WARNING);mdToast.show();

		}
	}


	public static String getStatusHtml(String str) {
		try {
			if (str.length() < 6) {
				int onlineUsers = Integer.parseInt(str.replaceAll("[^0-9\\.]", ""));
				if (onlineUsers >= 2000) {
					return "<font color=#FF0000><b> Online " + onlineUsers + " </b></font><font color=#000000> | </b></font> <b><font color=#FF0000> Limite 2000</b></font>;";
				} else if (onlineUsers >= 1000) {
					return "<font color=#ffbc40><b> Online " + onlineUsers + " </b></font><font color=#000000> | </b></font> <b><font color=#FF0000> Limite 2000</b></font>;";
				} else {
					return "<font color=#228b22><b> Online " + onlineUsers + " </b></font><font color=#000000> | </b></font> <b><font color=#FF0000> Limite 2000</b></font>";
				}
			}
		} catch (Exception e) {}
		return "<font color=#3b83bd><b>\uD83D\uDC64 SEM INFORMAÇÕES</b></font>";
	}
	private void checkServerStatus() {
		if (TunnelUtils.isNetworkOnline(this)) {
			textstatus.setText(Html.fromHtml("<font color=#ffbc40><b></b></font>"));
		}
	}


	public void getNotificationPermission(){
		try {
			if (Build.VERSION.SDK_INT > 32) {
				ActivityCompat.requestPermissions(this,
						new String[]{Manifest.permission.POST_NOTIFICATIONS},
						PERMISSION_REQUEST_CODE);
			}
		}catch (Exception e){

		}
	}

	@Override
	public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
		super.onRequestPermissionsResult(requestCode, permissions, grantResults);

		switch (requestCode) {
			case PERMISSION_REQUEST_CODE:
				// If request is cancelled, the result arrays are empty.
				if (grantResults.length > 0 &&
						grantResults[0] == PackageManager.PERMISSION_GRANTED) {
					// allow

				}  else {
					//deny
				}
		}

	}

	public void loadForm() {
		UserMessagingPlatform.loadConsentForm(
				this,
				new UserMessagingPlatform.OnConsentFormLoadSuccessListener() {
					@Override
					public void onConsentFormLoadSuccess(ConsentForm consentForm) {
						if (consentInformation.getConsentStatus() == ConsentInformation.ConsentStatus.REQUIRED) {
							consentForm.show(
									MainActivity.this,
									new ConsentForm.OnConsentFormDismissedListener() {
										@Override
										public void onConsentFormDismissed(@Nullable FormError formError) {
											if (consentInformation.getConsentStatus() == ConsentInformation.ConsentStatus.OBTAINED) {
												// App can start requesting ads.
											}

											// Handle dismissal by reloading form.
											loadForm();
										}
									});
						}
					}
				},
				new UserMessagingPlatform.OnConsentFormLoadFailureListener() {
					@Override
					public void onConsentFormLoadFailure(FormError formError) {
						// Handle Error.
					}
				}
		);
	}

	public class TabsAdapter extends PagerAdapter {

		@Override
		public int getCount() {
			return 2;
		}

		@Override
		public boolean isViewFromObject(View p1, Object p2) {
			return p1 == p2;
		}

		@Override
		public Object instantiateItem(ViewGroup container, int position) {
			int[] ids = new int[]{R.id.tab1, R.id.tab2};
			int id = 0;
			id = ids[position];
			return findViewById(id);
		}

		@Override
		public CharSequence getPageTitle(int position) {
			return titles.get(position);
		}

		private List<String> titles;

		public TabsAdapter(List<String> str) {
			titles = str;
		}
	}

	public void btnUpdate(View view) {

		pDialog = new SweetAlertDialog(MainActivity.this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setCustomImage(R.drawable.pngwing);
		pDialog.setTitleText(String.valueOf(Html.fromHtml("ACOMPANHE AS ATUALIZAÇÕES")));
		pDialog.setContentText(String.valueOf(Html.fromHtml("Entre em nosso grupo oficial")));
		pDialog.setCancelable(false);

		pDialog.setConfirmText("Grupo-OFC");
		pDialog.setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				// Abrir o link do canal no Telegram
				Uri uri = Uri.parse("https://t.me/sshbrasilofcgrupo");
				Intent intent = new Intent(Intent.ACTION_VIEW, uri);
				startActivity(intent);

				sweetAlertDialog.dismissWithAnimation();
			}
		});

		pDialog.setCancelText("Sair");
		pDialog.setCancelClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				pDialog.dismiss();
			}
		});

		pDialog.show();
		// Permite clicar nos links
		TextView messageView = pDialog.findViewById(R.id.content_text);
		if (messageView != null) {
			messageView.setMovementMethod(LinkMovementMethod.getInstance());
		}
	}

	public void btnTheme(View view) {
		// Exibe um diálogo de confirmação
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE);
		pDialog.setTitleText("MUDANÇA DE TEMA");
		pDialog.setSecondTitleText("Deseja fazer alteração do tema?");
		pDialog.setContentText("Erros podem ocorrer em alguns dispositivos Android devido à falta de memória");
		pDialog.setCustomImage(R.drawable.alterar);
		pDialog.setConfirmText(getString(R.string.yes));
		pDialog.setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				sweetAlertDialog.dismiss();

				CarregandoTema();

				// Cria um Handler para adicionar um atraso de 3 segundos
				new Handler().postDelayed(new Runnable() {
					@Override
					public void run() {
						// Verifica o tema atual
						int currentTheme = getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;
						// Inverte o tema e salva o novo estado
						int newTheme = (currentTheme == Configuration.UI_MODE_NIGHT_NO) ?
								AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO;
						SharedPreferences prefs1 = getSharedPreferences(THEME_PREF, MODE_PRIVATE);
						SharedPreferences.Editor editor = prefs1.edit();
						editor.putInt(THEME_MODE, newTheme);
						editor.apply();

						// Aplica o novo tema
						AppCompatDelegate.setDefaultNightMode(newTheme);
						recreate();
					}
				}, 3000); // Atraso de 3 segundos
			}
		});
		pDialog.setCancelText(getString(R.string.no));
		pDialog.setCancelClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sweetAlertDialog) {
				sweetAlertDialog.dismissWithAnimation();
			}
		});

		pDialog.getWindow().setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
	}

	private void CarregandoTema() {
		nops = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);
		nops.setTitleText("APLICANDO TEMA");
		nops.setContentText("Aguarde até o fim da aplicação");
		nops.setCancelable(true);
		nops.getWindow().setBackgroundDrawableResource(R.drawable.rounded_background);
		nops.show();
	}


	private void ShowMsgUpdate() {
		pDialog = new SweetAlertDialog(this, SweetAlertDialog.SUCCESS_TYPE);
		pDialog.setTitleText("App atualizado com sucesso");
		pDialog.setContentText("Seu aplicativo foi atualizado.\n\nCaso apresente algum bug limpe os dados do aplicativo.\n\n");
		pDialog.setConfirmText("Certo");
		pDialog.setCancelable(false);
		pDialog.setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() {
			@Override
			public void onClick(SweetAlertDialog sDialog) {
				sDialog.dismissWithAnimation();
				try {
					int idAtual = getBuildId(MainActivity.this);
					SharedPreferences prefs = getSharedPreferences("GERAL", Context.MODE_PRIVATE);
					SharedPreferences.Editor editor = prefs.edit();
					editor.putInt("last_version", idAtual);
					//editor.clear();
					editor.commit();
					editor.apply();
				} catch (Exception e) {
					e.printStackTrace();
				}
				File file = new File(getFilesDir(), "Config.json");
				file.delete();
				restart_app();
			}
		});
		Objects.requireNonNull(pDialog.getWindow()).setBackgroundDrawableResource(R.drawable.rounded_background);
		pDialog.show();
	}

	private void doLayout() {
		setContentView(R.layout.activity_main_drawer);
		statusconenect = findViewById(R.id.conectionstatus);
		mPager = findViewById(R.id.pager);
		TabBarView tabs = findViewById(R.id.sliding_tabs);
		String[] tabTitle = {"INICIO", "REGISTRO"};
		mPager.setAdapter(new TabsAdapter(Arrays.asList(tabTitle)));
		mPager.setOffscreenPageLimit(2);
		tabs.setViewPager(mPager);
		mAppUpdateManager = AppUpdateManagerFactory.create(this);
		appUpdateInfoTask = mAppUpdateManager.getAppUpdateInfo();
		installStateUpdatedListener = installState -> {
			if (installState.installStatus() == InstallStatus.DOWNLOADED) {
				popupSnackbarForCompleteUpdate();
			}
		};
		mAppUpdateManager.registerListener(installStateUpdatedListener);
		inAppUpdateType = IMMEDIATE;
		inAppUpdate();

		RecyclerView drawerListView = findViewById(R.id.recyclerDrawerView);
		LinearLayoutManager layoutManager = new LinearLayoutManager(this);

		mAdapter = new LogsAdapter(layoutManager, this);
		mAdapter.setOnItemClickListener(new LogsAdapter.OnItemClickListener() {
			@Override
			public void onItemClick(View view, int position, String logText) {
				// Implementação do onItemClick, se necessário
			}

			@Override
			public void onItemLongClick(View view, int position, String logText) {
				try {
					// Copiar log para a área de transferência
					Utils.copyToClipboard(MainActivity.this, logText);
					MDToast mdToast = MDToast.makeText(MainActivity.this, "Log copiado para a área de transferência", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS);mdToast.show();

				} catch (Exception e) {
					SkStatus.logException("Erro ao copiar Log", e);
					MDToast mdToast = MDToast.makeText(MainActivity.this, "Não foi possível copiar log", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);mdToast.show();

				}
			}
		});

		drawerListView.setAdapter(mAdapter);
		drawerListView.setLayoutManager(layoutManager);

		mAdapter.scrollToLastPosition();

		((FloatingActionButton) findViewById(R.id.clearLogs)).setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				Settings.clearSettings(MainActivity.this);
				SkStatus.clearLog();
				updateMainViews(MainActivity.this);
			}
		});

		FloatingActionButton copyLogButton = findViewById(R.id.copyLog);
		copyLogButton.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				try {
					// Obter o log completo selecionado
					int selectedPosition = mAdapter.getSelectedPosition();
					String selectedLog = String.valueOf(mAdapter.getItem(selectedPosition));

					// Copiar o log para a área de transferência
					Utils.copyToClipboard(MainActivity.this, selectedLog);
					MDToast mdToast = MDToast.makeText(MainActivity.this, "Log copiado para a área de transferência", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS);mdToast.show();

				} catch (Exception e) {
					SkStatus.logException("Erro ao copiar Log", e);
					MDToast mdToast = MDToast.makeText(MainActivity.this, "Não foi possível copiar log", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);mdToast.show();

				}
			}
		});
	}

	private void loadAds() {
		AdRequest adRequest = new AdRequest.Builder().build();
		com.google.android.gms.ads.interstitial.InterstitialAd.load(MainActivity.this, Inters, adRequest,
				new InterstitialAdLoadCallback() {
					@Override
					public void onAdLoaded(@NonNull com.google.android.gms.ads.interstitial.InterstitialAd interstitialAd) {
						// The mInterstitialAd reference will be null until
						// an ad is loaded.
						MainActivity.this.interstitialAd = interstitialAd;
                        interstitialAd.setFullScreenContentCallback(
								new FullScreenContentCallback() {
									@Override
									public void onAdDismissedFullScreenContent() {
										MainActivity.this.interstitialAd = null;
										loadAd(); // Carrega um novo anúncio após o atual ser dispensado
										MDToast.makeText(MainActivity.this, "Obrigado por apoiar nosso app ❤", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS).show();
									}

									@Override
									public void onAdFailedToShowFullScreenContent(@NonNull AdError adError) {
										// Called when fullscreen content failed to show.
										// Make sure to set your reference to null so you don't
										// show it a second time.
										MainActivity.this.interstitialAd = null;
										//Log.d("TAG", "The ad failed to show.");
									}

									@Override
									public void onAdShowedFullScreenContent() {
										// Called when fullscreen content is shown.
										//Log.d("TAG", "The ad was shown.");
									}
								});
					}

					@Override
					public void onAdFailedToLoad(@NonNull LoadAdError loadAdError) {
						// Handle the error
						//Log.i(TAG, loadAdError.getMessage());
						interstitialAd = null;

						@SuppressLint("DefaultLocale") String error =
								String.format(
										"domain: %s, code: %d, message: %s",
										loadAdError.getDomain(), loadAdError.getCode(), loadAdError.getMessage());
                    }
				});
	}
	@SuppressLint("NonConstantResourceId")
	@Override
	public boolean onNavigationItemSelected(@NonNull MenuItem item) {
		switch (item.getItemId()) {
			case R.id.updateConfig:
				// checkUpdate(false);
				return true;
			case R.id.miSettings:
				Intent intentSettings = new Intent(this, ConfigGeralActivity.class);
				startActivity(intentSettings);
				return true;

			case R.id.infoApp:
				Intent abt = new Intent(this, AboutActivity.class);
				startActivity(abt);
				return true;

			case R.id.miExit:
				new ExitDialogFragment(this)
						.show(getSupportFragmentManager(), "alertExit");
				return true;
		}
		return false;
	}


	@Override
	protected void onActivityResult(int requestCode, int resultCode,Intent data){
		super.onActivityResult(requestCode,resultCode,data);
		if(requestCode == RC_APP_UPDATE) {
			if (resultCode == RESULT_OK){
				MDToast mdToast = MDToast.makeText(MainActivity.this, "SSHBRASIL Lite download iniciado...", MDToast.LENGTH_SHORT, MDToast.TYPE_SUCCESS);mdToast.show();
			} else if (resultCode != RESULT_CANCELED){
				MDToast mdToast = MDToast.makeText(MainActivity.this, "SSHBRASIL Lite download cancelado", MDToast.LENGTH_SHORT, MDToast.TYPE_WARNING);mdToast.show();
			} else if (resultCode == RESULT_IN_APP_UPDATE_FAILED){
				MDToast mdToast = MDToast.makeText(MainActivity.this, "SSHBRASIL Lite download falhou", MDToast.LENGTH_SHORT, MDToast.TYPE_ERROR);mdToast.show();
			}
		} else if (requestCode == 2 && resultCode == RESULT_OK) {
			SkStatus.updateStateString(SkStatus.SSH_CONNECTING, getString(R.string.state_connecting));
			V2RayServiceManager.INSTANCE.startV2Ray(this);
		}
	}

	public void inAppUpdate(){
		try{

			appUpdateInfoTask.addOnSuccessListener(new com.google.android.gms.tasks.OnSuccessListener<AppUpdateInfo>() {
				@Override
				public void onSuccess(AppUpdateInfo result) {
					if(result.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE && result.isUpdateTypeAllowed(inAppUpdateType)){
						try{
							mAppUpdateManager.startUpdateFlowForResult(result, inAppUpdateType,MainActivity.this , RC_APP_UPDATE);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
			});
		} catch (Exception e) {
			e.printStackTrace();
		}
	}	public void popupSnackbarForCompleteUpdate(){
		try{
			Snackbar snackbar = Snackbar.make(findViewById(R.id.message),"Uma atualização acabou de ser baixada. \nReinicie o app",
					Snackbar.LENGTH_INDEFINITE);
			snackbar.setAction("INSTALAR", view ->{
				if(mAppUpdateManager != null){
					mAppUpdateManager.completeUpdate();
				}
			});
			snackbar.setActionTextColor(getResources().getColor(R.color.colorAccent));
			snackbar.show();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Override
	public void onBackPressed() {
		super.onBackPressed();
		new ExitDialogFragment(this).show(getSupportFragmentManager(), "alertExit");
	}

	@Override
	public void onResume() {
		super.onResume();
		checkUpdate(true);
		checkNetwork();
		IntentFilter intentFilter = new IntentFilter();
		intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
		registerReceiver(networkReceiver, intentFilter);

		if (mConfig.getModoDebug()) {
			mAdapter.setLogLevel(4);
		} else {
			mAdapter.setLogLevel(3);
		}

		loadServerData();

		if (!mTimerEnabled) {
			resumeTime(); // Retomar o tempo
		}

		SkStatus.addStateListener(this);

		try {
			mAppUpdateManager.getAppUpdateInfo().addOnSuccessListener(appUpdateInfo -> {
				if (appUpdateInfo.updateAvailability() == UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {
					try {
						mAppUpdateManager.startUpdateFlowForResult(
								appUpdateInfo,
								inAppUpdateType,
								this,
								RC_APP_UPDATE);
					} catch (IntentSender.SendIntentException e) {
						e.printStackTrace();
					}
				}
			});

			mAppUpdateManager.getAppUpdateInfo().addOnSuccessListener(appUpdateInfo -> {
				if (appUpdateInfo.installStatus() == InstallStatus.DOWNLOADED) {
					popupSnackbarForCompleteUpdate();
				}
			});
		} catch (Exception e) {
			e.printStackTrace();
		}
	}


	@Override
	public void onPostCreate(Bundle savedInstanceState, PersistableBundle persistentState) {
		super.onPostCreate(savedInstanceState, persistentState);

	}
	/**
	 * This method will be invoked when a button in the dialog is clicked.
	 *
	 * @param dialog the dialog that received the click
	 * @param which  the button that was clicked (ex.
	 *               {@link DialogInterface#BUTTON_POSITIVE}) or the position
	 */
	@Override
	public void onClick(DialogInterface dialog, int which) {

	}

	/**
	 * Called when a view has been clicked.
	 *
	 * @param v The view that was clicked.
	 */
	@Override
	public void onClick(View v) {

	}

	private AdSize getAdSize() {
		DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
		float widthPixels = displayMetrics.widthPixels;
		float density = displayMetrics.density;
		int adWidth = (int) (widthPixels / density);
		return AdSize.getCurrentOrientationAnchoredAdaptiveBannerAdSize(this, adWidth);
	}

	private void checkNetwork() {
		ConnectivityManager connManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo mWifi = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
		NetworkInfo mMobile = connManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
		TextView ipNetwork = findViewById(R.id.ipnetwork);
		String networkInfoText;

		if (mWifi.isConnected()) {
			networkInfoText = "<font color='#FFFFFF'>WIFI: </font>" + "<font color='#303030'>" + TunnelUtils.getLocalIpAddress() + "</font>";
		} else if (mMobile.isConnected()) {
			TelephonyManager telephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
			String networkOperatorName = telephonyManager.getNetworkOperatorName();
			networkInfoText = "<font color='#FFFFFF'>" + networkOperatorName + "</font>: " + "<font color='#303030'>" + TunnelUtils.getLocalIpAddress() + "</font>";
		} else {
			networkInfoText = "Sem conexão";
		}
		ipNetwork.setText(Html.fromHtml(networkInfoText));
	}

	private BroadcastReceiver networkReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(Context context, Intent intent) {
			checkNetwork();
		}
	};

}
